<!doctype html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>生成式PCB测试</title>
		<style>
			body {
				font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
				background: #f5f7fa;
				padding: 20px;
				display: flex;
				justify-content: center;
				align-items: center;
				min-height: 100vh;
				margin: 0;
			}
			.container {
				width: 100%;
				max-width: 800px;
				background: white;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				padding: 20px;
			}
			.input-group {
				display: flex;
				gap: 10px;
			}
			.input-field {
				flex: 1;
				padding: 12px 16px;
				border: 1px solid #ddd;
				border-radius: 24px;
				font-size: 1rem;
				outline: none;
				transition: border-color 0.3s;
			}
			.input-field:focus {
				border-color: #1a73e8;
			}
			.execute-button {
				background-color: #1a73e8;
				color: white;
				border: none;
				border-radius: 24px;
				padding: 12px 24px;
				cursor: pointer;
				transition: background-color 0.3s;
				font-weight: 500;
			}
			.execute-button:hover {
				background-color: #1557b0;
			}
			.result-container {
				margin-top: 20px;
				padding: 15px;
				background-color: #f8f9fa;
				border-radius: 8px;
				border-left: 4px solid #1a73e8;
				white-space: pre-wrap;
				font-family: monospace;
				max-height: 300px;
				overflow-y: auto;
			}
			.error {
				border-left-color: #d32f2f;
				background-color: #ffebee;
				color: #d32f2f;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h2>生成式PCB</h2>
			<div class="input-group">
				<input type="text" class="input-field" id="userInput" placeholder="输入您的指令..." onkeypress="handleKeyPress(event)" />
				<button class="execute-button" onclick="executeCommand()">执行</button>
			</div>
			<div id="resultContainer" class="result-container" style="display: none"></div>
		</div>

		<script>
			const userInput = document.getElementById('userInput');
			const resultContainer = document.getElementById('resultContainer');

			// 预设指令
			// const presetCommand = `const a = ['R', 100, 200, 300, 300, 0, 0]; async function creat() { const b = await eda.pcb_MathPolygon.createPolygon(a); console.log(b); const polyline = eda.pcb_PrimitivePolyline.create( "TestNetName", EPCB_LayerId.TOP_SILKSCREEN, b, 1, false ); } creat(); 已知Home > TPCB_PolygonSourceArray TPCB_PolygonSourceArray type 单多边形源数组 签名 export type TPCB_PolygonSourceArray = Array<'L' | 'ARC' | 'CARC' | 'C' | 'R' | 'CIRCLE' | 'number>; 1 备注 单多边形为首尾重合的一条不间断的线所描述的区域，如果首尾不重合将会自动重合。 单多边形的数据格式举例： [300, 200, 'L', 400, 200, 'ARC', 400, 220, 15, 'C', 200, 500, 400, 300, 100, 100] ['R', 100, 200, 300, 300, 0, 0] ['CIRCLE', 100, 200, 5] 单多边形的数据由以下几种模式组合而成： ① L 直线模式 x1 y1 L x2 y3 x3 y3 ... {number} x - 直线点的 X 坐标 {number} y - 直线点的 Y 坐标 ② ARC/CARC 圆弧模式 ARC 为两点交互，CARC 为中心圆弧交互 startX startY ARC arcAngle endX endY startX startY CARC arcAngle endX endY {number} startX - 起始 X {number} startY - 起始 Y {number} arcAngle - 圆弧角（负值为顺时针旋转；角度制） {number} endX - 终止 X {number} endY - 终止 Y ③ C 三阶贝塞尔模式 x1 y1 C x2 y2 x3 y3 x4 y4 ... {number} x - 控制点 X {number} y - 控制点 Y ④ R 矩形模式 R x y width height rot round {number} x - 左上点 X {number} y - 左上点 Y {number} width - 宽 {number} height - 高 {number} rotation - 旋转角度 {number} round - 圆角半径 ⑤ CIRCLE 圆形模式 CIRCLE cx cy radius {number} cx - 中心点 X {number} xy - 中心点 Y {number} radius - 半径`;

			function handleKeyPress(event) {
				if (event.key === 'Enter') {
					executeCommand();
				}
			}

			function executeCommand() {
				const userCommand = userInput.value.trim();
				if (!userCommand) return;

				// 拼接预设指令和用户输入
				const fullCommand = userCommand + '不要任何注释和解释，直接输出js';

				// 显示结果容器
				resultContainer.style.display = 'block';
				resultContainer.textContent = '执行中...';

				// 发送请求到后端
				const url = `https://ananwind.cn/lite.php?Question=${encodeURIComponent(fullCommand)}`;

				fetch(url)
					.then((response) => {
						if (!response.ok) {
							throw new Error('网络请求失败');
						}

						const reader = response.body.getReader();
						const decoder = new TextDecoder();
						let result = '';

						function processText() {
							return reader.read().then(({ done, value }) => {
								if (done) {
									// 执行返回的JS代码
									try {
										// 清理结果容器
										resultContainer.textContent = '';
										resultContainer.classList.remove('error');
										let newResult = result.slice(13, -3);
										console.log(newResult);
										// 执行返回的JS代码
										eval(newResult);

										// 如果没有错误，显示执行成功
										if (resultContainer.textContent === '') {
											resultContainer.textContent = '代码执行成功';
										}
									} catch (error) {
										resultContainer.textContent = `执行错误: ${error.message}`;
										resultContainer.classList.add('error');
									}
									return;
								}

								// 解码并添加文本
								const chunk = decoder.decode(value, { stream: true });
								result += chunk;

								// 继续处理下一个数据块
								return processText();
							});
						}

						return processText();
					})
					.catch((error) => {
						resultContainer.textContent = `请求错误: ${error.message}`;
						resultContainer.classList.add('error');
					});
			}
		</script>
	</body>
</html>
